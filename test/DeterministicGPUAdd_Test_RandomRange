
#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include <stdio.h>
#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <time.h>


/*********************************************************************************************************************
									DECLARATION OF MACROS AND GLOBAL VARIABLES
*********************************************************************************************************************/
#define N 51200000
#define ITERATION 100

double average, variance, std_dev, sum1, sum2, minV, maxV, minG, maxG;
int	   DECIMALPLACE = 1;

__device__ double pow(int DECIMALPLACE) {
	double temp = 10.0;
	for (int i = DECIMALPLACE - 1; i > 0; i--)
	{
		temp *= 10;
	}
	return temp;
}

__device__ __forceinline__ float atomicMinFloat(float *addr, float value) {
	float old;
	old = (value >= 0) ? __int_as_float(atomicMin((int *)addr, __float_as_int(value))) :
		__uint_as_float(atomicMax((unsigned int *)addr, __float_as_uint(value)));

	return old;
}

__device__ __forceinline__ float atomicMaxFloat(float * addr, float value) {
	float old;
	old = (value >= 0) ? __int_as_float(atomicMax((int *)addr, __float_as_int(value))) :
		__uint_as_float(atomicMin((unsigned int *)addr, __float_as_uint(value)));

	return old;
}

__global__ void findMaxKernel(float *g_inData, float *d_max) {
	int globalID = blockDim.x * blockIdx.x + threadIdx.x;

	atomicMaxFloat(&d_max[blockIdx.x], g_inData[globalID]);
	__syncthreads();

}

__global__ void findMinKernel(float *g_inData, float *d_min) {
	int globalID = blockDim.x * blockIdx.x + threadIdx.x;

	atomicMinFloat(&d_min[blockIdx.x], g_inData[globalID]);
	__syncthreads();

}

__global__ void AtomicAddKernelULLInt(double *g_inData, unsigned long long int *g_outData, int DECIMALPLACE) {
	extern __shared__ double sharedMem[];

	int threadID = threadIdx.x;
	int globalID = blockDim.x * blockIdx.x + threadIdx.x;

	sharedMem[threadID] = g_inData[globalID];
	__syncthreads();


	unsigned long long int temp = round(sharedMem[threadID] * pow(DECIMALPLACE));
	atomicAdd(&g_outData[blockIdx.x], temp);
	__syncthreads();
}

__global__ void AddAbsMinKernel(double* g_inData, double min) {
	int globalID = blockDim.x * blockIdx.x + threadIdx.x;

	g_inData[globalID] += abs(min);
}


/***
Random number generator in the range of [0,1)
RAND_MAX = 32767
*/
double GetRand()
{

	return (double)rand() / (double)RAND_MAX;
}


/****
	Find maximum, minimum, mean, variance and standard deviation of a vector
**/
void Statistics(double* h_inData, int n, bool verbosity) {
	average = 0, variance = 0, std_dev = 0, sum1 = 0, sum2 = 0, minV = 0, maxV = 0;
	minV = h_inData[0];

	/*  Compute the sum of all elements
		and the max and min	*/
	for (int i = 0; i < n; i++)
	{
		if (verbosity)
		{
			sum1 += h_inData[i];
		}
		maxV = fmax(maxV, h_inData[i]);
		minV = fmin(minV, h_inData[i]);
	}

	if (verbosity)
	{

	average = sum1 / (double)n;

	/*  Compute  variance  and standard deviation  */
	for (int i = 0; i < n; i++)
	{
		sum2 += powf((h_inData[i] - average), 2.0);
	}
	variance = sum2 / (double)n;
	std_dev = sqrt(variance);

	
		printf("Maximum number is %.25lf\n", maxV);
		printf("Minimum number is %.25lf\n", minV);
		printf("Average of all elements is %.25lf\n", average);
		printf("variance of all elements is %.25lf\n", variance);
		printf("Standard deviation is %.25lf\n", std_dev);
	}
}

//void Statistics(double* h_inData, int n, int gridSize, int blockSize) {
//	minV = 0, maxV = 0;
//
//	(float*)realloc(h_inData, n * sizeof(float));
//
//	float *d_inData; cudaMalloc(&d_inData, N * sizeof(float));
//	cudaMemcpy(d_inData, h_inData, N * sizeof(float), cudaMemcpyHostToDevice);
//	float *d_min; cudaMalloc(&d_min, gridSize * sizeof(float));
//	float *d_max; cudaMalloc(&d_max, gridSize * sizeof(float));
//
//
//	findMaxKernel << <gridSize, blockSize >> > (d_inData, d_max);
//	cudaDeviceSynchronize();
//
//	findMinKernel << <gridSize, blockSize >> > (d_inData, d_min);
//	cudaDeviceSynchronize();
//
//	float *h_min = (float*)malloc(gridSize * sizeof(float));
//	float *h_max = (float*)malloc(gridSize * sizeof(float));
//
//	cudaMemcpy(h_min, d_min, gridSize * sizeof(float), cudaMemcpyDeviceToHost);
//	cudaMemcpy(h_max, d_max, gridSize * sizeof(float), cudaMemcpyDeviceToHost);
//
//	cudaFree(d_inData);
//	cudaFree(d_max);
//	cudaFree(d_min);
//
//	n = gridSize;
//
//	while (n > 100000) {
//		gridSize = (n + blockSize - 1) / blockSize;
//		float *d_inMin; cudaMalloc(&d_inMin, n * sizeof(float));
//		float *d_inMax; cudaMalloc(&d_inMax, n * sizeof(float));
//		cudaMemcpy(d_inMin, h_min, n * sizeof(float), cudaMemcpyHostToDevice);
//		cudaMemcpy(d_inMax, h_max, n * sizeof(float), cudaMemcpyHostToDevice);
//
//		float *d_outMin; cudaMalloc(&d_outMin, gridSize * sizeof(float));
//		float *d_outMax; cudaMalloc(&d_outMax, gridSize * sizeof(float));
//
//		findMaxKernel << <gridSize, blockSize >> > (d_inMin, d_outMin);
//		cudaDeviceSynchronize();
//
//		findMinKernel << <gridSize, blockSize >> > (d_inMax, d_outMax);
//		cudaDeviceSynchronize();
//
//		(float*)realloc(h_min, gridSize * sizeof(float));
//		(float*)realloc(h_max, gridSize * sizeof(float));
//
//		cudaMemcpy(h_min, d_outMin, gridSize * sizeof(float), cudaMemcpyDeviceToHost);
//		cudaMemcpy(h_max, d_outMax, gridSize * sizeof(float), cudaMemcpyDeviceToHost);
//
//		n = gridSize;
//		cudaFree(d_inMax);
//		cudaFree(d_inMin);
//		cudaFree(d_outMax);
//		cudaFree(d_outMin);
//	}
//
//	minV = h_min[0];
//	maxV = h_max[0];
//
//	for (int i = 0; i < n; i++)
//	{
//		maxV = fmax(maxV, h_max[i]);
//		minV = fmin(minV, h_min[i]);
//	}
//
//	printf("Maximum number is %.25lf\n", maxV);
//	printf("Minimum number is %.25lf\n", minV);
//
//	free(h_min);
//	free(h_max);
//
//}


int FindMaxDecimalPlaces(int blockSize, int gridSize) {
	double temp;
	int places = -1;

	temp = LLONG_MAX / (maxG * blockSize * gridSize);
	while (temp > 1)
	{
		temp /= 10;
		places++;
	}
	std::cout << "Largest decimal places is " << places << std::endl;
	return places;

}

double timeElapsed(clock_t begin, clock_t end) {
	return (double)(end - begin) / CLOCKS_PER_SEC;
}



/*********************************************************************************************************************
														MAIN
*********************************************************************************************************************/
int main() {
	/*********************************************************************************************************************
											CONFIGURE CUDA GRID
	*********************************************************************************************************************/
	int blockSize;
	int gridSize;
	blockSize = 512;
	gridSize = (N + blockSize - 1) / blockSize;

	double* results = (double*)malloc(sizeof(double) * ITERATION);
	double* accResults = (double*)malloc(sizeof(double) * ITERATION);
	double testSum;
	clock_t begin, end;
	double time_spent;


	for (int i = 0; i < ITERATION; i++)
	{
		printf("%dth...\n", i);

		/*********************************************************************************************************************
													RAW DATA GENERATION
		*********************************************************************************************************************/
		double *h_inData = (double*)malloc(N * sizeof(double));
		double *d_inData; cudaMalloc(&d_inData, N * sizeof(double));

		srand(i);

		printf("Data initilization begins...\n");
		begin = clock();
		for (int i = 0; i < N; i++)
		{
			h_inData[i] = GetRand();
		}
		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("Data initilization spent %lf seconds.\n", time_spent);


		testSum = 0;
		printf("CPU Summation begins...\n");
		begin = clock();
		for (int i = 0; i < N; i++)
		{
			testSum += h_inData[i];
		}
		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("CPU Summation spent %lf seconds.\n", time_spent);

		/*********************************************************************************************************************
													DATA STATISTICS
		*********************************************************************************************************************/
		//std::cout << "Raw data analysis:" << std::endl;
		printf("Statistics begins...\n");
		begin = clock();

		Statistics(h_inData, N, gridSize, blockSize);

		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("Statistics spent %lf seconds.\n", time_spent);

		minG = minV;
		maxG = maxV;
		//std::cout << "Raw data analysis ends." << std::endl;

		/*********************************************************************************************************************
													CHECK IF ANY ELEMENT IS NEGATIVE
		*********************************************************************************************************************/
		if (minG < 0) // if yes, launch a kernel to turn all values into positive
		{
			cudaMemcpy(d_inData, h_inData, N * sizeof(double), cudaMemcpyHostToDevice);
			AddAbsMinKernel << < gridSize, blockSize >> > (d_inData, minG);
			cudaMemcpy(h_inData, d_inData, N * sizeof(double), cudaMemcpyDeviceToHost);
			Statistics(h_inData, N, false);
		}


		/*********************************************************************************************************************
													FIND MAXIMUM DECIMAL PLACES
		*********************************************************************************************************************/
		DECIMALPLACE = FindMaxDecimalPlaces(blockSize, gridSize);
		//DECIMALPLACE = 14;

		cudaMemcpy(d_inData, h_inData, N * sizeof(double), cudaMemcpyHostToDevice);

		long long int sum = 0;
	

		unsigned long long int *h_outData = (unsigned long long int*)malloc(gridSize * sizeof(unsigned long long int));

		unsigned long long int *d_outData; cudaMalloc(&d_outData, gridSize * sizeof(unsigned long long int));

		printf("Kernel begins...\n");
		begin = clock();

		AtomicAddKernelULLInt << <gridSize, blockSize, blockSize * sizeof(double) >> > (d_inData, d_outData, DECIMALPLACE);
		cudaDeviceSynchronize();

		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("Kernel spent %.15lf seconds.\n", time_spent);

		cudaMemcpy(h_outData, d_outData, gridSize * sizeof(unsigned long long int), cudaMemcpyDeviceToHost);

		for (int j = 0; j < gridSize; j++)
		{
			sum += h_outData[j];
		}

		if (minG < 0)
		{
			results[i] = ((double)sum / pow(10, DECIMALPLACE)) - ((abs(minG) * N));
		}
		else
		{
			results[i] = (double)sum / pow(10, DECIMALPLACE);
		}

		accResults[i] = 1 - (abs(results[i] - testSum) / testSum);

	
		//printf("Accuracy: %.50lf", accResults[i]);

		cudaFree(d_inData);
		cudaFree(d_outData);
		free(h_inData);
		free(h_outData);
		printf("----------------------------------------------------------\n");
	}

	Statistics(accResults, ITERATION, true);

}
