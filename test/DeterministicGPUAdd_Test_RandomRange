
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include "cublas_v2.h"

#include <stdio.h>
#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <time.h>

#include <cstdio>
#include <cstdlib>



#if __DEVICE_EMULATION__
#define DEBUG_SYNC __syncthreads();
#else
#define DEBUG_SYNC
#endif

#if (__CUDA_ARCH__ < 200)
#define int_mult(x,y)	__mul24(x,y)	
#else
#define int_mult(x,y)	x*y
#endif

/*********************************************************************************************************************
									DECLARATION OF MACROS AND GLOBAL VARIABLES
*********************************************************************************************************************/
#define N 5120000
#define ITERATION 10

const int blockSize1 = 4096 / 2;

const int threads = 64;

#define inf ULLONG_MAX 

double average, variance, std_dev, sum1, sum2, minV, maxV, minG, maxG;
int	   DECIMALPLACE = 1;

__device__ double pow(int DECIMALPLACE) {
	double temp = 10.0;
	for (int i = DECIMALPLACE - 1; i > 0; i--)
	{
		temp *= 10;
	}
	return temp;
}


__device__ void warp_reduce_max(volatile double smem[64])
{

	smem[threadIdx.x] = smem[threadIdx.x + 32] > smem[threadIdx.x] ?
		smem[threadIdx.x + 32] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 16] > smem[threadIdx.x] ?
		smem[threadIdx.x + 16] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 8] > smem[threadIdx.x] ?
		smem[threadIdx.x + 8] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 4] > smem[threadIdx.x] ?
		smem[threadIdx.x + 4] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 2] > smem[threadIdx.x] ?
		smem[threadIdx.x + 2] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 1] > smem[threadIdx.x] ?
		smem[threadIdx.x + 1] : smem[threadIdx.x];

}

__device__ void warp_reduce_min(volatile double smem[64])
{

	smem[threadIdx.x] = smem[threadIdx.x + 32] < smem[threadIdx.x] ?
		smem[threadIdx.x + 32] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 16] < smem[threadIdx.x] ?
		smem[threadIdx.x + 16] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 8] < smem[threadIdx.x] ?
		smem[threadIdx.x + 8] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 4] < smem[threadIdx.x] ?
		smem[threadIdx.x + 4] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 2] < smem[threadIdx.x] ?
		smem[threadIdx.x + 2] : smem[threadIdx.x];

	smem[threadIdx.x] = smem[threadIdx.x + 1] < smem[threadIdx.x] ?
		smem[threadIdx.x + 1] : smem[threadIdx.x];

}

template<int els_per_block, int threads>
__global__ void find_min_max(double* in, double* out)
{
	__shared__ double smem_min[64];
	__shared__ double smem_max[64];

	int tid = threadIdx.x + blockIdx.x*els_per_block;

	double max = -inf;
	double min = inf;
	double val;

	const int iters = els_per_block / threads;

#pragma unroll  
	for (int i = 0; i < iters; i++)
	{

		val = in[tid + i * threads];

		min = val < min ? val : min;
		max = val > max ? val : max;

	}


	if (threads == 32)
	{
		smem_min[threadIdx.x + 32] = 0.0f;
		smem_max[threadIdx.x + 32] = 0.0f;

	}

	smem_min[threadIdx.x] = min;
	smem_max[threadIdx.x] = max;


	__syncthreads();

	if (threadIdx.x < 32)
	{
		warp_reduce_min(smem_min);
		warp_reduce_max(smem_max);
	}
	if (threadIdx.x == 0)
	{
		out[blockIdx.x] = smem_min[threadIdx.x]; // out[0] == ans
		out[blockIdx.x + gridDim.x] = smem_max[threadIdx.x];
	}

}

template<int threads>
__global__ void find_min_max_dynamic(double* in, double* out, int n, int start_adr, int num_blocks)
{

	__shared__ double smem_min[64];
	__shared__ double smem_max[64];

	int tid = threadIdx.x + start_adr;

	double max = -inf;
	double min = inf;
	double val;


	// tail part
	int mult = 0;
	for (int i = 1; mult + tid < n; i++)
	{
		val = in[tid + mult];

		min = val < min ? val : min;
		max = val > max ? val : max;

		mult = int_mult(i, threads);
	}

	// previously reduced MIN part
	mult = 0;
	int i;
	for (i = 1; mult + threadIdx.x < num_blocks; i++)
	{
		val = out[threadIdx.x + mult];

		min = val < min ? val : min;

		mult = int_mult(i, threads);
	}

	// MAX part
	for (; mult + threadIdx.x < num_blocks * 2; i++)
	{
		val = out[threadIdx.x + mult];

		max = val > max ? val : max;

		mult = int_mult(i, threads);
	}


	if (threads == 32)
	{
		smem_min[threadIdx.x + 32] = 0.0f;
		smem_max[threadIdx.x + 32] = 0.0f;

	}

	smem_min[threadIdx.x] = min;
	smem_max[threadIdx.x] = max;

	__syncthreads();

	if (threadIdx.x < 32)
	{
		warp_reduce_min(smem_min);
		warp_reduce_max(smem_max);
	}
	if (threadIdx.x == 0)
	{
		out[blockIdx.x] = smem_min[threadIdx.x]; // out[0] == ans
		out[blockIdx.x + gridDim.x] = smem_max[threadIdx.x];
	}


}


__global__ void AtomicAddKernelULLInt(double *g_inData, unsigned long long int *g_outData, int DECIMALPLACE) {
	extern __shared__ double sharedMem[];

	int threadID = threadIdx.x;
	int globalID = blockDim.x * blockIdx.x + threadIdx.x;

	sharedMem[threadID] = g_inData[globalID];
	__syncthreads();


	unsigned long long int temp = round(sharedMem[threadID] * pow(DECIMALPLACE));
	atomicAdd(&g_outData[blockIdx.x], temp);
	__syncthreads();
}

__global__ void AddAbsMinKernel(double* g_inData, double min) {
	int globalID = blockDim.x * blockIdx.x + threadIdx.x;

	g_inData[globalID] += abs(min);
}


/***
Random number generator in the range of [0,1)
RAND_MAX = 32767
*/
double GetRand()
{

	return (double)rand() / (double)RAND_MAX *1000000;
}


/****
	Find maximum, minimum, mean, variance and standard deviation of a vector
**/
void Statistics(double* h_inData, int n, bool verbosity) {
	average = 0, variance = 0, std_dev = 0, sum1 = 0, sum2 = 0, minV = 0, maxV = 0;
	minV = h_inData[0];

	/*  Compute the sum of all elements
		and the max and min	*/
	for (int i = 0; i < n; i++)
	{
		if (verbosity)
		{
			sum1 += h_inData[i];
		}
		maxV = fmax(maxV, h_inData[i]);
		minV = fmin(minV, h_inData[i]);
	}

	if (verbosity)
	{

	average = sum1 / (double)n;

	/*  Compute  variance  and standard deviation  */
	for (int i = 0; i < n; i++)
	{
		sum2 += powf((h_inData[i] - average), 2.0);
	}
	variance = sum2 / (double)n;
	std_dev = sqrt(variance);

	
		printf("Maximum number is %.25lf\n", maxV);
		printf("Minimum number is %.25lf\n", minV);
		printf("Average of all elements is %.25lf\n", average);
		printf("variance of all elements is %.25lf\n", variance);
		printf("Standard deviation is %.25lf\n", std_dev);
	}
}

void findBlockSize(int* whichSize, int* num_el)
{

	const float pretty_big_number = 24.0f*1024.0f*1024.0f;

	float ratio = float((*num_el)) / pretty_big_number;


	if (ratio > 0.8f)
		(*whichSize) = 5;
	else if (ratio > 0.6f)
		(*whichSize) = 4;
	else if (ratio > 0.4f)
		(*whichSize) = 3;
	else if (ratio > 0.2f)
		(*whichSize) = 2;
	else
		(*whichSize) = 1;


}

void compute_reduction(double* d_in, double* d_out, int num_els)
{

	int whichSize = -1;

	findBlockSize(&whichSize, &num_els);

	//whichSize = 5;

	int block_size = powf(2, whichSize - 1)*blockSize1;
	int num_blocks = num_els / block_size;
	int tail = num_els - num_blocks * block_size;
	int start_adr = num_els - tail;


	if (whichSize == 1)
		find_min_max<blockSize1, threads> << < num_blocks, threads >> > (d_in, d_out);
	else if (whichSize == 2)
		find_min_max<blockSize1 * 2, threads> << < num_blocks, threads >> > (d_in, d_out);
	else if (whichSize == 3)
		find_min_max<blockSize1 * 4, threads> << < num_blocks, threads >> > (d_in, d_out);
	else if (whichSize == 4)
		find_min_max<blockSize1 * 8, threads> << < num_blocks, threads >> > (d_in, d_out);
	else
		find_min_max<blockSize1 * 16, threads> << < num_blocks, threads >> > (d_in, d_out);

	find_min_max_dynamic<threads> << < 1, threads >> > (d_in, d_out, num_els, start_adr, num_blocks);

}


int FindMaxDecimalPlaces(int blockSize, int gridSize) {
	double temp;
	int places = -1;

	temp = LLONG_MAX / (maxG * blockSize * gridSize);
	while (temp > 1)
	{
		temp /= 10;
		places++;
	}
	std::cout << "Largest decimal places is " << places << std::endl;
	return places;

}

double timeElapsed(clock_t begin, clock_t end) {
	return (double)(end - begin) / CLOCKS_PER_SEC;
}



/*********************************************************************************************************************
														MAIN
*********************************************************************************************************************/
int main() {
	/*********************************************************************************************************************
											CONFIGURE CUDA GRID
	*********************************************************************************************************************/
	int blockSize;
	int gridSize;
	blockSize = 512;
	gridSize = (N + blockSize - 1) / blockSize;

	double* results = (double*)malloc(sizeof(double) * ITERATION);
	double* accResults = (double*)malloc(sizeof(double) * ITERATION);
	double testSum;
	clock_t begin, end;
	double time_spent;


	for (int i = 0; i < ITERATION; i++)
	{
		printf("%dth...\n", i);

		/*********************************************************************************************************************
													RAW DATA GENERATION
		*********************************************************************************************************************/
		double *h_inData = (double*)malloc(N * sizeof(double));
		double *d_inData; cudaMalloc(&d_inData, N * sizeof(double));

		srand(i);

		printf("Data initilization begins...\n");
		begin = clock();
		for (int i = 0; i < N; i++)
		{
			h_inData[i] = GetRand();
		}
		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("Data initilization spent %lf seconds.\n", time_spent);


		testSum = 0;
		printf("CPU Summation begins...\n");
		begin = clock();
		/*for (int i = 0; i < N; i++)
		{
			testSum += h_inData[i];
		}*/
		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("CPU Summation spent %lf seconds.\n", time_spent);

		
		/*******************************************************************************************************
													FIND MIN AND MAX
		********************************************************************************************************/
		
		begin = clock();

		cublasHandle_t handle;
		cublasStatus_t stat;
		double* d_in_min_max;   cudaMalloc((void**)&d_in_min_max, N * sizeof(double));
		cudaMemcpy(d_in_min_max, h_inData, N * sizeof(double), cudaMemcpyHostToDevice);
		int max_idx, min_idx;
		cublasCreate(&handle);

		stat = cublasIdamax(handle, N, d_in_min_max, 1, &max_idx);
		if (stat != CUBLAS_STATUS_SUCCESS)
			printf("Max failed\n");

		stat = cublasIdamin(handle, N, d_in_min_max, 1, &min_idx);
		if (stat != CUBLAS_STATUS_SUCCESS)
			printf("Min failed\n");

		maxV = h_inData[max_idx - 1];
		minV = h_inData[min_idx - 1];
		maxG = maxV;
		minG = minV;
		
		cublasDestroy(handle);
		cudaFree(d_in_min_max);

		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("Statistics spent %lf seconds.\n", time_spent);
		std::cout << "Raw data analysis ends." << std::endl;

		/*********************************************************************************************************************
													CHECK IF ANY ELEMENT IS NEGATIVE
		*********************************************************************************************************************/
		if (minG < 0) // if yes, launch a kernel to turn all values into positive
		{
			cudaMemcpy(d_inData, h_inData, N * sizeof(double), cudaMemcpyHostToDevice);
			AddAbsMinKernel << < gridSize, blockSize >> > (d_inData, minG);
			cudaMemcpy(h_inData, d_inData, N * sizeof(double), cudaMemcpyDeviceToHost);
			Statistics(h_inData, N, false);
		}


		/*********************************************************************************************************************
													FIND MAXIMUM DECIMAL PLACES
		*********************************************************************************************************************/
		DECIMALPLACE = FindMaxDecimalPlaces(blockSize, gridSize);
		//DECIMALPLACE = 14;

		cudaMemcpy(d_inData, h_inData, N * sizeof(double), cudaMemcpyHostToDevice);

		long long int sum = 0;
	

		unsigned long long int *h_outData = (unsigned long long int*)malloc(gridSize * sizeof(unsigned long long int));

		unsigned long long int *d_outData; cudaMalloc(&d_outData, gridSize * sizeof(unsigned long long int));

		printf("Kernel begins...\n");
		begin = clock();

		AtomicAddKernelULLInt << <gridSize, blockSize, blockSize * sizeof(double) >> > (d_inData, d_outData, DECIMALPLACE);
		cudaDeviceSynchronize();

		end = clock();
		time_spent = timeElapsed(begin, end);
		printf("Kernel spent %.15lf seconds.\n", time_spent);

		cudaMemcpy(h_outData, d_outData, gridSize * sizeof(unsigned long long int), cudaMemcpyDeviceToHost);

		for (int j = 0; j < gridSize; j++)
		{
			sum += h_outData[j];
		}

		if (minG < 0)
		{
			results[i] = ((double)sum / pow(10, DECIMALPLACE)) - ((abs(minG) * N));
		}
		else
		{
			results[i] = (double)sum / pow(10, DECIMALPLACE);
		}

		accResults[i] = 1 - (abs(results[i] - testSum) / testSum);

	
		//printf("Accuracy: %.50lf", accResults[i]);

		cudaFree(d_inData);
		cudaFree(d_outData);
		free(h_inData);
		free(h_outData);
		printf("----------------------------------------------------------\n");
	}

	Statistics(accResults, ITERATION, true);

}
